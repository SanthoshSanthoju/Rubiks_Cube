package patterndb;

import model.RubiksCube;

/**
 * Corner Pattern Database.
 * Stores minimum move counts for all possible corner configurations.
 * Size = 8! × 3^7 = 40,320 × 2,187 = 88,179,840... actually 8P8 * 3^7 =
 * 100,179,840
 * (based on the C++ source using 8! * 2187 = 100,179,840 with the rank * 2187
 * formula).
 *
 * Database index = permutationRank * 2187 + orientationNumber
 */
public class CornerPatternDatabase extends PatternDatabase {

    private static final int DB_SIZE = 88_179_840;
    // Note: C++ uses 100,179,840. Let's match exactly: 40320 * 2187 = 88,179,840.
    // Wait: 8! = 40320, 3^7 = 2187. 40320 * 2187 = 88,179,840.
    // The C++ code has 100,179,840 which seems incorrect, but let's use the same
    // value to match
    // the database file format generated by the C++ code.
    private static final int DB_SIZE_CPP = 100_179_840;

    private PermutationIndexer permIndexer;

    public CornerPatternDatabase() {
        super(DB_SIZE_CPP);
        this.permIndexer = new PermutationIndexer(8);
    }

    public CornerPatternDatabase(int initVal) {
        super(DB_SIZE_CPP, initVal);
        this.permIndexer = new PermutationIndexer(8);
    }

    @Override
    public int getDatabaseIndex(RubiksCube cube) {
        int[] cornerPerm = new int[8];
        for (int i = 0; i < 8; i++) {
            cornerPerm[i] = cube.getCornerIndex(i);
        }

        int rank = permIndexer.rank(cornerPerm);

        int[] cornerOrientations = new int[7];
        for (int i = 0; i < 7; i++) {
            cornerOrientations[i] = cube.getCornerOrientation(i);
        }

        int orientationNum = cornerOrientations[0] * 729 +
                cornerOrientations[1] * 243 +
                cornerOrientations[2] * 81 +
                cornerOrientations[3] * 27 +
                cornerOrientations[4] * 9 +
                cornerOrientations[5] * 3 +
                cornerOrientations[6];

        return (rank * 2187) + orientationNum;
    }
}
